#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TREE_HT 100
#define MAX_CHARS 256

typedef struct MinHeapNode {
    char data;
    unsigned freq;
    struct MinHeapNode *left;
    struct MinHeapNode *right;
} MinHeapNode;

typedef struct MinHeap {
    unsigned size;
    unsigned capacity;
    MinHeapNode **array;
} MinHeap;

MinHeapNode* createNode(char data, unsigned freq) {
    MinHeapNode *temp = (MinHeapNode *)malloc(sizeof(MinHeapNode));
    temp->data  = data;
    temp->freq  = freq;
    temp->left  = NULL;
    temp->right = NULL;
    return temp;
}

MinHeap* createMinHeap(unsigned capacity) {
    MinHeap *minHeap = (MinHeap *)malloc(sizeof(MinHeap));
    minHeap->size = 0;
    minHeap->capacity = capacity;
    minHeap->array = (MinHeapNode **)malloc(minHeap->capacity * sizeof(MinHeapNode *));
    return minHeap;
}

void swapMinHeapNode(MinHeapNode **a, MinHeapNode **b) {
    MinHeapNode *t = *a;
    *a = *b;
    *b = t;
}

void minHeapify(MinHeap *minHeap, int idx) {
    int smallest = idx;
    int left  = 2 * idx + 1;
    int right = 2 * idx + 2;

    if (left < (int)minHeap->size && minHeap->array[left]->freq < minHeap->array[smallest]->freq)
        smallest = left;
    if (right < (int)minHeap->size && minHeap->array[right]->freq < minHeap->array[smallest]->freq)
        smallest = right;
    if (smallest != idx) {
        swapMinHeapNode(&minHeap->array[smallest], &minHeap->array[idx]);
        minHeapify(minHeap, smallest);
    }
}

int isSizeOne(MinHeap *minHeap) {
    return (minHeap->size == 1);
}

MinHeapNode* extractMin(MinHeap *minHeap) {
    MinHeapNode *temp = minHeap->array[0];
    minHeap->array[0] = minHeap->array[minHeap->size - 1];
    --minHeap->size;
    minHeapify(minHeap, 0);
    return temp;
}

void insertMinHeap(MinHeap *minHeap, MinHeapNode *minHeapNode) {
    int i;
    ++minHeap->size;
    i = (int)minHeap->size - 1;
    while (i && minHeapNode->freq < minHeap->array[(i - 1) / 2]->freq) {
        minHeap->array[i] = minHeap->array[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    minHeap->array[i] = minHeapNode;
}

MinHeap* buildMinHeap(char data[], int freq[], int size) {
    MinHeap *minHeap = createMinHeap(size);
    int i;
    for (i = 0; i < size; ++i)
        minHeap->array[i] = createNode(data[i], freq[i]);
    minHeap->size = size;
    {
        int n = (int)minHeap->size - 1;
        for (i = (n - 1) / 2; i >= 0; --i)
            minHeapify(minHeap, i);
    }
    return minHeap;
}

int isLeaf(MinHeapNode *root) {
    return !(root->left) && !(root->right);
}

MinHeapNode* buildHuffmanTree(char data[], int freq[], int size) {
    MinHeapNode *left, *right, *top;
    MinHeap *minHeap = buildMinHeap(data, freq, size);

    while (!isSizeOne(minHeap)) {
        left = extractMin(minHeap);
        right = extractMin(minHeap);
        top = createNode('$', left->freq + right->freq);
        top->left  = left;
        top->right = right;
        insertMinHeap(minHeap, top);
    }

    {
        MinHeapNode *root = extractMin(minHeap);
        free(minHeap->array);
        free(minHeap);
        return root;
    }
}

void storeCodes(MinHeapNode *root, int arr[], int top, char codes[][MAX_TREE_HT]) {
    int i;
    if (root->left) {
        arr[top] = 0;
        storeCodes(root->left, arr, top + 1, codes);
    }
    if (root->right) {
        arr[top] = 1;
        storeCodes(root->right, arr, top + 1, codes);
    }
    if (isLeaf(root)) {
        char codeStr[MAX_TREE_HT];
        for (i = 0; i < top; i++)
            codeStr[i] = arr[i] + '0';
        codeStr[top] = '\0';
        strcpy(codes[(unsigned char)root->data], codeStr);
    }
}

int buildFrequency(const char *text, char data[], int freq[]) {
    int asciiFreq[MAX_CHARS];
    int i, idx;

    for (i = 0; i < MAX_CHARS; i++)
        asciiFreq[i] = 0;

    for (i = 0; text[i] != '\0'; i++) {
        unsigned char c = (unsigned char)text[i];
        asciiFreq[c]++;
    }

    idx = 0;
    for (i = 0; i < MAX_CHARS; i++) {
        if (asciiFreq[i] > 0) {
            data[idx] = (char)i;
            freq[idx] = asciiFreq[i];
            idx++;
        }
    }
    return idx;
}

void encodeText(const char *text, char codes[][MAX_TREE_HT], char *encoded) {
    char buffer[2 * MAX_TREE_HT];
    int i;
    encoded[0] = '\0';

    for (i = 0; text[i] != '\0'; i++) {
        unsigned char c = (unsigned char)text[i];
        strcpy(buffer, codes[c]);
        strcat(encoded, buffer);
    }
}

void decodeText(const char *encoded, MinHeapNode *root, char *decoded) {
    int decodedIndex = 0;
    MinHeapNode *current = root;
    int i;

    for (i = 0; encoded[i] != '\0'; i++) {
        if (encoded[i] == '0')
            current = current->left;
        else
            current = current->right;
        if (isLeaf(current)) {
            decoded[decodedIndex++] = current->data;
            current = root;
        }
    }
    decoded[decodedIndex] = '\0';
}

void freeTree(MinHeapNode *root) {
    if (!root) return;
    freeTree(root->left);
    freeTree(root->right);
    free(root);
}

int main() {
    char text[1000];
    char data[MAX_CHARS];
    int freq[MAX_CHARS];
    char codes[MAX_CHARS][MAX_TREE_HT];
    int arr[MAX_TREE_HT];
    int i;
    int sizeUnique;
    MinHeapNode *root;
    char encoded[8000];
    char decoded[1000];
    int originalBits, compressedBits;
    double ratio;
    FILE *fp;
    size_t len;

    printf("===== HUFFMAN CODING PROJECT (C) =====\n");
    printf("Enter a text to compress (no spaces at the beginning):\n");

    if (!fgets(text, sizeof(text), stdin)) {
        printf("Error reading input.\n");
        return 1;
    }

    len = strlen(text);
    if (len > 0 && text[len - 1] == '\n')
        text[len - 1] = '\0';

    if (strlen(text) == 0) {
        printf("Empty input. Exiting.\n");
        return 0;
    }

    for (i = 0; i < MAX_CHARS; i++)
        codes[i][0] = '\0';

    sizeUnique = buildFrequency(text, data, freq);

    printf("\nCharacter Frequencies:\nChar\tFreq\n");
    for (i = 0; i < sizeUnique; i++) {
        if (data[i] == ' ')
            printf("' ' \t%d\n", freq[i]);
        else
            printf("%c\t%d\n", data[i], freq[i]);
    }

    root = buildHuffmanTree(data, freq, sizeUnique);
    storeCodes(root, arr, 0, codes);

    printf("\nHuffman Codes for each character:\nChar\tCode\n");
    for (i = 0; i < sizeUnique; i++) {
        if (data[i] == ' ')
            printf("' ' \t%s\n", codes[(unsigned char)data[i]]);
        else
            printf("%c\t%s\n", data[i], codes[(unsigned char)data[i]]);
    }

    encodeText(text, codes, encoded);

    printf("\nOriginal Text: %s\n", text);
    printf("Encoded Text:\n%s\n", encoded);

    decodeText(encoded, root, decoded);
    printf("\nDecoded Text: %s\n", decoded);

    originalBits = (int)strlen(text) * 8;
    compressedBits = (int)strlen(encoded);

    printf("\nApproximate Compression Info:\n");
    printf("Original size  : %d bits\n", originalBits);
    printf("Compressed size: %d bits\n", compressedBits);
    if (compressedBits > 0) {
        ratio = (double)compressedBits / originalBits * 100.0;
        printf("Compression ratio: %.2f%% of original\n", ratio);
    }

    /* Save everything to file */
    fp = fopen("huffman_output.txt", "w");
    if (fp == NULL) {
        printf("\nError opening file to save output.\n");
    } else {
        fprintf(fp, "===== HUFFMAN CODING OUTPUT =====\n\n");
        fprintf(fp, "Input Text:\n%s\n\n", text);

        fprintf(fp, "Character Frequencies:\n");
        fprintf(fp, "Char\tFreq\n");
        for (i = 0; i < sizeUnique; i++) {
            if (data[i] == ' ')
                fprintf(fp, "' ' \t%d\n", freq[i]);
            else
                fprintf(fp, "%c\t%d\n", data[i], freq[i]);
        }

        fprintf(fp, "\nHuffman Codes:\n");
        fprintf(fp, "Char\tCode\n");
        for (i = 0; i < sizeUnique; i++) {
            if (data[i] == ' ')
                fprintf(fp, "' ' \t%s\n", codes[(unsigned char)data[i]]);
            else
                fprintf(fp, "%c\t%s\n", data[i], codes[(unsigned char)data[i]]);
        }

        fprintf(fp, "\nEncoded Text:\n%s\n", encoded);
        fprintf(fp, "\nDecoded Text:\n%s\n", decoded);

        fprintf(fp, "\nApproximate Compression Info:\n");
        fprintf(fp, "Original size  : %d bits\n", originalBits);
        fprintf(fp, "Compressed size: %d bits\n", compressedBits);
        if (compressedBits > 0) {
            ratio = (double)compressedBits / originalBits * 100.0;
            fprintf(fp, "Compression ratio: %.2f%% of original\n", ratio);
        }

        fprintf(fp, "\n===== END OF OUTPUT =====\n");
        fclose(fp);
        printf("\nAll information saved to file: huffman_output.txt\n");
    }

    freeTree(root);
    printf("\n===== END OF PROGRAM =====\n");
    return 0;
}
